- try 

	[[x*y|x<-[1..10]]|y<-[1..10]]

  crashes

  I'd like 

	Matrix [[x*y|x<-[1..10]]|y<-[1..10]]

  to generate a times table

  trace compile:

	A1 = [[x*y|x<-[1..10]]|y<-[1..10]]

  before compile #1

	.. $$lcomp0 ..
	{
		$$lcomp0 = 
		{
			$$result = x * y;
			x = [1..10];
			y = zombie;
		}
	}

  after compile #1

	A1 = .. $$lcomp0 ..
	{
		$$lcomp0 = foldr $$fn1 [] [1..10]
		{
			y = zombie;
			$$fn1 x $$sofar = (x * y) : $$sofar;
			foldr = zombie;
		}
	}

  before compile #2

	A1 = .. $$lcomp1 ..
	{
		$$lcomp1 = 
		{
			$$result = $$lcomp0;
			y = [1..10];
			foldr = zombie;
		}
	}

  after compile #2

	A1 = .. $$lcomp1 ..
	{
		$$lcomp1 = foldr $$fn1 [] [1..10]
		{
			foldr = zombie;
			$$fn1 y $$sofar = $lcomp0 : $$sofar;
		}
	}

  the problem is this -- we have:

	'[' expr TK_BOR TK_IDENT TK_FROM expr {
		make new scope
	}
	frompred_list ']' {
		pop scope
	}
	
  we move the trees for the first two exprs inside the scope, but we don't
  move any locals they make

  so if expr contains an lcomp, it ends up as a peer of the lcomp we are
  defining, rather than as a child

  so, we generate:

	A1 = .. $$lcomp1 ..
	{
		$$lcomp0 = foldr $$fn1 [] [1..10]
		{
			y = zombie;
			$$fn1 x $$sofar = (x * y) : $$sofar;
			foldr = zombie;
		}

		$$lcomp1 = foldr $$fn1 [] [1..10]
		{
			foldr = zombie;
			$$fn1 y $$sofar = $$lcomp0 : $$sofar;
		}
	}

  we should generate:

	A1 = .. $$lcomp1 ..
	{
		$$lcomp1 = foldr $$fn1 [] [1..10]
		{
			$$fn1 y $$sofar = $$lcomp0 : $$sofar
			{
				$$lcomp0 = foldr $$fn2 [] [1..10]
				{
					$$fn2 x $$sofar = (x * y) : $$sofar;
				}
			}
		}
	}





  before compile #1

	A1 = .. $$lcomp0 ..
	{
		$$lcomp0 = 
		{
			$$result = x * y;
			x = [1..10];
			y = zombie;
		}
	}

  after compile #1

	A1 = .. $$lcomp0 ..
	{
		$$lcomp0 = foldr $$fn1 [] [1..10]
		{
			y = zombie;
			$$fn1 x $$sofar = (x * y) : $$sofar;
			foldr = zombie;
		}
	}

  before compile #2

	A1 = .. $$lcomp1 ..
	{
		$$lcomp1 = 
		{
			$$result = $$lcomp0
			{
				$$lcomp0 = foldr $$fn1 [] [1..10]
				{
					$$fn1 x $$sofar = (x * $$lcomp1.y) : $$sofar;
					foldr = zombie;
				}
			}
			y = [1..10];
			foldr = zombie;
		}
	}

  after compile #2

	A1 = .. $$lcomp1 ..
	{
		$$lcomp1 = foldr $$fn2 [] [1..10]
		{
			$$fn2 y $$sofar = $$lcomp0 : $$sofar
			{
				$$lcomp0 = foldr $$fn1 [] [1..10]
				{
					$$fn1 x $$sofar = (x * y) : $$sofar;
				}
			}
		}
	}



  correct! but it fails because things are bound incorrectly ... the
  innermost y is bound to the left-over $$lcomp1.y

  if we destroy unused sys we still leave the ref to $$lcomp1.y in $$fn1 ...
  it's never rebound to $$fn2.y

  trace rebindings: we only rebind the 'x' during compile #1

  when we copy the value of $$result into $$fn2, we also move any generated
  syms for the tree, but we don't rebind the code in those syms

  is y on the rename list, but not spotted because the ref is in the generated
  sym? get tree_copy_rewrite() to print the rewrite list

  yup, y is on the rewrite list for the copy

  so compile_move_syms() needs a rewrite list too ... tricky! can we update
  the compile trees in-place? or will we need to copy the whole graph?

  best to copy the graph ... need to recurse for all children too

  compile_move_syms() needs to check that the syms it is moving are really
  locals of that tree ... not good enough to just test ->generated, we need to
  test for the location too

  forget the glr-parser thing

  try again

	A1 = .. $$lcomp1 ..
	{
		$$lcomp1 = foldr $$fn2 [] [1..10]
		{
			$$fn2 y $$sofar = $$lcomp0 : $$sofar
			{
				$$lcomp0 = foldr $$fn1 [] [1..10]
				{
					$$fn1 x $$sofar = (x * y) : $$sofar;
				}
			}
		}
	}

  correct binding!

  but we still don't work, because the old tree, which we have't removed,
  still has references to dead syms recorded by compile_link_make() & friends






	A1 = [[x*y|x<-[1..10]]|y<-[1..10]]

  before compile #1

	A1 = .. $$lcomp0 ..
	{
		$$lcomp0 = 
		{
			$$result = x * y;
			x = [1..10];
			y = zombie;
		}
	}

  after compile #1

	A1 = .. $$lcomp0 ..
	{
		$$lcomp0 = foldr $$fn1 [] [1..10]
		{
			$$result = x * A1.y;
			x = [1..10];
			y = zombie;
			$$fn1 x $$sofar = (x * y) : $$sofar;
			foldr = zombie;
		}
		y = zombie;
	}



now dies when copying result of first lcomp into A1.$$lcomp1.$$result

compile_copy_tree: copying tree from compile(0x39c94b0) A1  to compile(0x3c32b10) A1.$$lcomp1.$$result 
with generated children: (0x35cf5a0) SYM_VALUE A1.$$lcomp0; 
compile_copy_sym: copying A1.$$lcomp0 to scope of compile(0x3c32b10) A1.$$lcomp1.$$result 
compile_copy_sym: copying A1.$$lcomp0.$$result to scope of compile(0x3c32c00) A1.$$lcomp1.$$result.$$lcomp0 
compile_copy_sym: copying A1.$$lcomp0.x to scope of compile(0x3c32c00) A1.$$lcomp1.$$result.$$lcomp0 
nip2: compile.c:2021: compile_copy_sym: Assertion `!compile_lookup( dest, name
)' failed.

trying to copy  A1.$$lcomp0.x to A1.$$lcomp1.$$result.$$lcomp0 and it's there
already











  before compile #2

	A1 = .. $$lcomp1 ..
	{
		$$lcomp1 = 
		{
			$$result = $$lcomp0
			{
				$$lcomp0 = foldr A1.$$lcomp0.$$fn1 [] [1..10]
				{
					$$fn1 x $$sofar = (x * $$lcomp1.y) : $$sofar;
					foldr = zombie;
				}
			}
			y = [1..10];
			foldr = zombie;
		}
	}

  after compile #2

	A1 = .. $$lcomp1 ..
	{
		$$lcomp1 = foldr $$fn2 [] [1..10]
		{
			$$fn2 y $$sofar = $$lcomp0 : $$sofar
			{
				$$lcomp0 = foldr $$fn1 [] [1..10]
				{
					$$fn1 x $$sofar = (x * y) : $$sofar;
				}
			}
		}
	}



- compile_map_all() now works boittom-up, has this broken anything?

  seems OK

- which gtk are we using for the windows build? new gtks come from the main gtk
  site now, rather than tor's homepage:

	http://ftp.gnome.org/pub/GNOME/binaries/win32/

  should be all zips, so we could automate?

- have a toggle in find colour calib for "linearise"

  another option that uses the greyscale to set the zero, but does not adjust
  gamma?

- apply calib should work for groups

- Hist / New should be "Plot [] (im_identity 1)" or similar, and have
  the tone thing as a custom tone curve

- "nip2 -w < test.ws", then modify workspace, then CTRL-S saves as a file
  called "stdin" ... o.O

- quit while a thumbnail is painting: IMAGEs are leaked? seems esp. bad with
  greyc, perhaps just because it's so slow

- there's some left-recursion in the parser, eg. comma_list, is this easily
  fixable?

- add (*) (operator sections) ... need a binup / uop production? can't
  do this without losing precedence stuff, it'll need a separate production
  for sections

- pattern matching

  	fred (Image x) = rot90 x

  is equivalent to

  	fred x
		= rot90 x, is_Image x
		= error "bad args"

  also for list and complex

  	fred (a:x) = x
	fred [a, b, c] = 
	fred [a, b, ...] =
	fred (a, b) = 
	fred [(a, b), (c, d), ...] = 
	fred [Image x, Matrix y] =



- image view windows are missing 'max' buttons?

  caused by gtk_window_set_transient_for() in iwindow

  not much we can do here, except remove the transient_for behaviour

- do we leak for IMAGEVEC/DOUBLEVEC/etc. in vips_call.c? I think we might

- test classmodel_dict_new() ... part of classmodel member automation

  need to implement member edit for OPTION groups

	classmodel_done_member() ... read widget set -> model
	classmodel_buildedit_member( ... model -> build widget set 

  part of the [["key",value]] arg type

WONTFIX
=======

- toolkits / find doesn't find builtins on their name ... eg. search for
  "im_add"

  too hard to fix with the way searching is done now

- turn on update regions during drag, fix the x pos, try dragging, horrible
  flickering as we update twice, once after the drag motion and once after the
  recomp

  if you comment out the explicit vobject_refresh() in 
  regionview_model_update() the flickering goes, but region dragging is then
  very unresponsive

  fix this when we get fast recomp back again

- have a test_types.ws ... test arithmetic on all combinations of _types?

- panner would be cool

- tooltips on Expression rows always show unedited formula

  could special-case formula for things with expression RHS?

- what about iimage, iregion, iarrow ... can we member automate these? why are
  they different?

- can't see error indications in noedit mode

  should set a red background for display area as well as for rowview button?

- need to be able to override cons to be able to make a List class :-(

  see reduce.c:1710

  this will change the strictness of cons ... how much breakage will this
  cause? very unclear

  try this as a quick hack

  need to do this before we can finish List

  need List to make gamma easy

- unselected column headers are too like the bg colour on windows?

- python uses z.real and z.imag to extract real/image, should we add this too?

  we don't really have complex as a true class, so it would be rather odd

  need to add "[a].head" etc as well

- python blocks complex->real with casts ... insists you use .imag/.real or
  abs()

- if nip sees a IM_RW_IMAGE argument, it could automatically do this:

	int
	im_flood_blob_copy( IMAGE *in, IMAGE *out, int x, int y, PEL *ink )
	{
		IMAGE *t;

		if( !(t = im_open_local( out, "im_flood_blob_copy", "t" )) ||
			im_copy( in, t ) ||
			im_flood_blob( t, x, y, ink, NULL ) ||
			im_copy( t, out ) ) 
			return( -1 );

		return( 0 );
	}

  so it would turn a single IM_RW_IMAGE arg into a paired input and output
  arg

  could make im_lineset() into a regular inplace func and rely on nip to wrap
  and unwrap

  junk flood_blob_copy

  nip could do this lazilly ... if we see the user doing

     im_line (im_line ...) ...

  then we could make one memory image and call im_line twice on it
  destructively ... cool! we'd need to check refcounts to make sure the
  intermediate wasn't being used anywhere else

  hmm! might actually be very hard, we don't have true refcounts for things in
  the heap

  need to do it on read instead: 

    - for image i

    - use as an IM_RW_IMAGE arg ... copy to a memory area and pass in memory
      handle

    - return memory area IMAGE j, and set a flag saying "can operate on
      destructively"

    - if we use j as an IM_RW_IMAGE arg, skip the copy and just pass memory
      area in destructively ... we now have two ImageInfo sharing a single
      IMAGE

    - !!!!

    - does ImageInfo allow IMAGE sharing? not sure it does

    - maybe this needs to be a vips8 feature when we'll have refcounts on
      IMAGE

- tooltip on column says which other columns items in this column refer to,
  and which columns refer to items in this column

- how about a nip start folder common to all versions

  so nip2-7.11.14 tries

    .nip2-7.11.14/start
    .nip2-7.11/start
    .nip2-7/start
    .nip2/start

  or maybe

    .nip2/7.11.14/start
    .nip2/7.11/start
    .nip2/7/start
    .nip2/start

  bit less cluttered

  also, we could have

    .nip2/tmp

  and not have multiple nip2 tmp areas

  workspace recover after crash could break though ... maybe keep ws saves in
  .nip2/7.11.4/tmp?

- think again about class arg checks 

  is there some way we can avoid the _check overhead? or at least check less 
  often

- plotpresent/imagepresent could have a common base class with the focus stuff
  in? also kb nav, zoom, drag-scroll

  a bit difficult, because we want two different policies on window resize:
  plot should change the object to match the window

- photographic negative should also be in image/levels ?

  no, it does ->sRGB, (255-) etc., so it's better as a filter

- gtk+ 2.12 has a treeview widget with rectangular select and grid lines

  use instead of gtksheet?

- stop image flickering on clock recomp?

  want background pattern to be a property of the image display widget, not
  the image?

  so we fade in tiles when that section of the image has never been displayed
  before (eg. on scroll or zoom)

  we don't fade when that section has been painted and we are just changing
  the image (eg. on recalc)

  if fadesteps == 1, only paint the sections of the tile for which mask == 255

  this way we will never paint the bg pattern

  need some hack for scroll/zoom ; test for mask == 255 would be slow :(

